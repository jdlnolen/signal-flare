---
phase: 04-quality-and-ci
plan: 03
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/slack/client.test.ts
  - src/slack/poller.test.ts
  - src/tools/ask-human.test.ts
  - .github/workflows/ci.yml
  - vitest.config.ts
autonomous: true
requirements:
  - PKG-06
  - PKG-07

must_haves:
  truths:
    - "Polling loop test verifies that a thread containing only bot messages returns found:false (roadmap-required test case)"
    - "Polling loop test verifies that a valid human reply returns found:true with the reply text"
    - "Slack client test verifies botUserId is resolved from auth.test() at creation time"
    - "ask-human tool test verifies the full question-post-poll-respond lifecycle with mocked Slack"
    - "GitHub Actions CI workflow runs lint, typecheck, build, and test as parallel jobs on PR and push to main"
    - "`npm run coverage` passes with thresholds enforced"
  artifacts:
    - path: "src/slack/client.test.ts"
      provides: "Slack client creation and auth tests"
      contains: "describe.*createSlackClient"
    - path: "src/slack/poller.test.ts"
      provides: "Poll-for-reply tests including bot-only thread case"
      contains: "bot messages returns"
    - path: "src/tools/ask-human.test.ts"
      provides: "MCP tool lifecycle tests"
      contains: "describe.*ask.human"
    - path: ".github/workflows/ci.yml"
      provides: "GitHub Actions CI pipeline"
      contains: "matrix.*node-version"
    - path: "vitest.config.ts"
      provides: "Final coverage thresholds (may be adjusted from plan 01)"
      contains: "thresholds"
  key_links:
    - from: "src/slack/poller.test.ts"
      to: "src/slack/poller.ts"
      via: "pollForReply with mock WebClient"
      pattern: "pollForReply"
    - from: ".github/workflows/ci.yml"
      to: "package.json"
      via: "npm ci + npm run coverage"
      pattern: "npm run coverage"
---

<objective>
Write tests for the async Slack-dependent modules (client, poller, ask-human tool) and create the GitHub Actions CI workflow. Adjust coverage thresholds to pass based on actual measured coverage.

Purpose: Cover the critical async paths — especially the polling loop's bot-message filtering (explicitly required by roadmap) — and deliver the CI pipeline that enforces quality on every PR.
Output: 3 test files for Slack integration modules, CI workflow file, passing coverage thresholds.
</objective>

<execution_context>
@/Users/jdlnolen/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jdlnolen/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-quality-and-ci/04-RESEARCH.md
@.planning/phases/04-quality-and-ci/04-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write tests for Slack client, poller, and ask-human tool</name>
  <files>
    src/slack/client.test.ts
    src/slack/poller.test.ts
    src/tools/ask-human.test.ts
  </files>
  <action>
Read each source file before writing its test: `src/slack/client.ts`, `src/slack/poller.ts`, `src/tools/ask-human.ts`.

**src/slack/client.test.ts** — Test Slack client factory functions:
- Mock `@slack/web-api` using `vi.mock('@slack/web-api', factory)` with inline `vi.fn()` inside the factory (NOT external variables — ESM hoisting pitfall).
- Test `createSlackClient`:
  - auth.test() succeeds → botUserId resolved from response
  - auth.test() fails → throws error
  - WebClient constructed with correct token
- Test `createSlackClientDirect`:
  - Sets botUserId to "" (per Phase 2 decision — hook handlers never poll)
  - Does NOT call auth.test()

**src/slack/poller.test.ts** — Test `pollForReply` (CRITICAL — contains roadmap-required test):
- Use mock WebClient with `conversations.replies` returning controlled data.
- Use tiny timing params: `timeoutMs: 50-100`, `initialDelayMs: 5`, `maxDelayMs: 10`.

REQUIRED test cases:
1. **Bot-only thread returns found:false** (ROADMAP REQUIREMENT): Mock `conversations.replies` returning only messages with `bot_id` set. Verify `result.found === false`. This is the specific test case from the roadmap: "polling loop must verify that a thread containing only bot messages returns null (no false positive self-detection)".
2. **Valid human reply returns found:true**: Mock replies including a message with `user: 'U_HUMAN'` (no bot_id). Verify `result.found === true` and `result.text` matches.
3. **Self-messages filtered**: Messages where `user === botUserId` are skipped even without bot_id.
4. **Timeout with no replies**: Empty thread (only root message) → returns found:false after timeout.
5. **isSubstantiveReply filtering** (if applicable — check source): Verify acknowledgment-only replies are filtered.
6. **Exponential backoff**: Verify `conversations.replies` is called multiple times with increasing delays (check call count over time window).

Also test `sleep` utility if exported.

**src/tools/ask-human.test.ts** — Test the MCP tool handler:
- Mock `src/slack/client.js` (createSlackClient) and `src/slack/poller.js` (pollForReply).
- Mock `src/slack/messages.js` (buildQuestionMessage).
- Test the tool's handler function (the function passed to registerTool):
  - Normal flow: question posted to Slack → poll returns human reply → tool returns reply text
  - Poll timeout: pollForReply returns found:false → tool returns timeout error with isError:true
  - Slack API error during post: → tool returns error message with isError:true
  - Urgency levels passed through correctly
  - Options included in message when provided
- If the tool handler is not easily extracted for testing (tightly coupled to MCP server), mock at the module boundary level and test the core logic functions it calls.
  </action>
  <verify>
Run `npx vitest run src/slack/client.test.ts src/slack/poller.test.ts src/tools/ask-human.test.ts` — all tests pass.
Specifically verify the bot-only thread test exists and passes: `npx vitest run src/slack/poller.test.ts -t "bot messages"`.
  </verify>
  <done>Slack client tests verify auth resolution. Poller tests include the roadmap-required bot-only-thread test case. Ask-human tests cover the full tool lifecycle. All pass with mocked Slack API.</done>
</task>

<task type="auto">
  <name>Task 2: Create GitHub Actions CI workflow and finalize coverage thresholds</name>
  <files>
    .github/workflows/ci.yml
    vitest.config.ts
  </files>
  <action>
Create `.github/workflows/ci.yml`:

```yaml
name: CI

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  lint:
    name: Lint
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: 22
          cache: npm
      - run: npm ci
      - run: npm run lint
      - run: npm run format:check

  typecheck:
    name: Typecheck
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: 22
          cache: npm
      - run: npm ci
      - run: npm run typecheck

  build:
    name: Build
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: 22
          cache: npm
      - run: npm ci
      - run: npm run build

  test:
    name: Test (Node ${{ matrix.node-version }})
    runs-on: ubuntu-latest
    strategy:
      matrix:
        node-version: [18, 20, 22]
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}
          cache: npm
      - run: npm ci
      - run: npm run coverage
```

Key design per locked decisions:
- Triggers on PRs targeting main AND direct pushes to main
- lint, typecheck, build, test run as separate parallel jobs
- Only test uses Node version matrix (18, 20, 22 — all current LTS)
- lint/typecheck/build use Node 22 (latest LTS, no need for matrix)
- `npm run coverage` in test job enforces thresholds via vitest.config.ts
- Lint job includes `format:check` to catch formatting regressions
- Build job catches tsup config issues (per locked decision)

After all tests from plans 02 and 03 are written, run:
```bash
npx vitest run --coverage
```

Review the actual coverage numbers. Adjust thresholds in `vitest.config.ts` if needed:
- Target 90% if achievable (locked decision target)
- Minimum 85% (research recommendation for initial threshold)
- The CONTEXT.md says "Claude can adjust if practical"

If any module's coverage is below threshold, either:
1. Add targeted tests to bring it up, or
2. Add the module to the coverage exclude list if it's an integration boundary

Ensure `npm run coverage` passes with the final thresholds.
  </action>
  <verify>
Run `npm run coverage` — must exit 0 (all tests pass, thresholds met).
Run `npm run lint` — must exit 0 (CI workflow yaml doesn't affect lint, but all test files must pass).
Verify `.github/workflows/ci.yml` exists with correct structure.
Verify the workflow has all 4 jobs: lint, typecheck, build, test.
Verify test job has matrix with [18, 20, 22].
  </verify>
  <done>CI workflow exists at `.github/workflows/ci.yml` with parallel lint/typecheck/build/test jobs. Coverage thresholds are set and enforced. `npm run coverage` passes locally.</done>
</task>

</tasks>

<verification>
1. `npm run coverage` — all tests pass, coverage thresholds met
2. `npm run lint` — all files (including new test files) pass lint
3. `.github/workflows/ci.yml` exists with 4 parallel jobs and Node matrix [18, 20, 22]
4. Bot-only-thread test case exists in poller.test.ts and passes
5. `npm run typecheck` — passes
6. `npm run build` — passes
</verification>

<success_criteria>
Complete test suite covering Slack client, polling loop (including the roadmap-required bot-message test), and ask-human tool. GitHub Actions CI workflow enforces lint, typecheck, build, and tests on every PR. Coverage thresholds are met and enforced.
</success_criteria>

<output>
After completion, create `.planning/phases/04-quality-and-ci/04-03-SUMMARY.md`
</output>
