---
phase: 01-slack-infrastructure-and-mcp-tool
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - tsconfig.json
  - tsup.config.ts
  - src/config.ts
  - src/slack/client.ts
  - src/slack/messages.ts
  - src/types.ts
autonomous: true
requirements:
  - SLCK-02
  - SLCK-03
  - SLCK-04

must_haves:
  truths:
    - "Config module validates env vars at startup and fails fast with clear errors"
    - "Slack client initializes WebClient and resolves bot user ID via auth.test"
    - "Block Kit builder produces color-coded attachment messages with urgency levels"
    - "Messages @mention the configured SLACK_USER_ID"
    - "Code snippets render in rich_text_preformatted blocks"
    - "Options render as numbered list with reply instructions"
  artifacts:
    - path: "src/config.ts"
      provides: "Zod-validated env var config with fail-fast"
      exports: ["loadConfig", "Config"]
      contains: "SLACK_BOT_TOKEN"
    - path: "src/slack/client.ts"
      provides: "WebClient wrapper with bot user ID resolution"
      exports: ["createSlackClient", "SlackClient"]
    - path: "src/slack/messages.ts"
      provides: "Block Kit message builders for questions, timeouts, and notices"
      exports: ["buildQuestionMessage"]
      contains: "attachments"
    - path: "src/types.ts"
      provides: "Shared TypeScript interfaces"
    - path: "package.json"
      provides: "Project dependencies and scripts"
      contains: "@modelcontextprotocol/sdk"
    - path: "tsconfig.json"
      provides: "TypeScript configuration"
  key_links:
    - from: "src/slack/messages.ts"
      to: "src/types.ts"
      via: "imports UrgencyLevel type"
      pattern: "import.*types"
    - from: "src/slack/client.ts"
      to: "src/config.ts"
      via: "receives config for token"
      pattern: "SLACK_BOT_TOKEN"
---

<objective>
Set up the Signal Flare project scaffold and build the three foundation modules: config validation, Slack client wrapper, and Block Kit message builder.

Purpose: These modules are the independently-testable building blocks that the MCP server (Plan 02) wires together. Getting them right first means the integration layer is pure glue code.
Output: Working TypeScript project with config, Slack client, and message builder modules.
</objective>

<execution_context>
@/Users/jdlnolen/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jdlnolen/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-slack-infrastructure-and-mcp-tool/01-CONTEXT.md
@.planning/phases/01-slack-infrastructure-and-mcp-tool/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Project scaffold with dependencies and TypeScript config</name>
  <files>
    package.json
    tsconfig.json
    tsup.config.ts
    src/types.ts
    .gitignore
  </files>
  <action>
Initialize the project:

1. Create `package.json` with:
   - name: "signal-flare", version: "0.1.0", type: "module"
   - Runtime deps: `@modelcontextprotocol/sdk` ^1.27.0, `@slack/web-api` ^7.14.1, `zod` ^3.25.0
   - Dev deps: `typescript` ^5.7.0, `tsup` ^8.0.0, `tsx` ^4.0.0, `vitest` ^2.0.0, `@types/node` ^20.0.0, `@slack/types` (latest)
   - Scripts: `"build": "tsup"`, `"dev": "tsx src/server.ts"`, `"test": "vitest run"`, `"typecheck": "tsc --noEmit"`
   - `"bin"` field: `{ "signal-flare": "./dist/server.js" }` (for future global install)
   - `"main": "./dist/server.js"`, `"files": ["dist"]`

2. Create `tsconfig.json`:
   - target: "ES2022", module: "Node16", moduleResolution: "Node16"
   - strict: true, skipLibCheck: true, outDir: "dist", rootDir: "src"
   - esModuleInterop: true, resolveJsonModule: true, declaration: true

3. Create `tsup.config.ts`:
   - Entry: `["src/server.ts"]`
   - Format: `["esm"]`
   - Target: "node20"
   - Clean: true, dts: true
   - Banner to add shebang: `{ js: '#!/usr/bin/env node' }`

4. Create `src/types.ts` with shared types:
   - `UrgencyLevel = "high" | "normal" | "low"`
   - `AskHumanParams` interface: question (string), context (string?), options (string[]?), urgency (UrgencyLevel?), session_id (string?)
   - `PollResult` interface: found (boolean), text (string?), user (string?), ts (string?), elapsedMs (number?)
   - `ToolResponse` interface: reply (string), replied_by (string), response_time_ms (number), selected_option (string | null), selected_option_index (number | null)

5. Create `.gitignore`: node_modules, dist, .env, *.tsbuildinfo

6. Run `npm install` to generate lockfile.

IMPORTANT: All logging must use `console.error()` — add an ESLint-style comment at the top of types.ts reminding future code: "// NOTE: Never use console.log() in this project — it corrupts MCP stdio transport"
  </action>
  <verify>
Run `npm install && npx tsc --noEmit` — both succeed with zero errors. Verify `node_modules/@modelcontextprotocol/sdk` and `node_modules/@slack/web-api` exist.
  </verify>
  <done>Project compiles, all dependencies installed, types.ts exports shared interfaces used by subsequent modules.</done>
</task>

<task type="auto">
  <name>Task 2: Config module and Slack client wrapper</name>
  <files>
    src/config.ts
    src/slack/client.ts
  </files>
  <action>
1. Create `src/config.ts`:
   - Define Zod schema for config: SLACK_BOT_TOKEN (string, startsWith "xoxb-"), SLACK_CHANNEL_ID (string, startsWith "C"), SLACK_USER_ID (string, optional), SEND_DELAY_MS (coerce number, int, min 0, default 0), POLL_TIMEOUT_MS (coerce number, int, min 0, default 600000)
   - Export `loadConfig()` function that calls `ConfigSchema.safeParse(process.env)`. On failure: log formatted error to stderr (`console.error`) and call `process.exit(1)`. On success: return typed config.
   - Export the `Config` type via `z.infer<typeof ConfigSchema>`.

2. Create `src/slack/client.ts`:
   - Define `SlackClient` interface with: `web` (WebClient instance), `botUserId` (string), `channelId` (string)
   - Export `createSlackClient(config: Config)` async function that:
     a. Creates `new WebClient(config.SLACK_BOT_TOKEN)`
     b. Calls `client.auth.test()` to get the bot's own user ID (this resolves Open Question #2 from research)
     c. If auth.test fails, log error to stderr and throw
     d. Returns `SlackClient` object with the WebClient, botUserId from auth.test response, and channelId from config
   - All errors logged via `console.error()` — zero `console.log()` calls

Note: The `auth.test()` call at startup serves dual purpose — validates the token AND retrieves the bot user ID needed for poll filtering. This is the recommended approach from the research.
  </action>
  <verify>
Run `npx tsc --noEmit` — compiles with zero errors. Verify `src/config.ts` exports `loadConfig` and `Config`. Verify `src/slack/client.ts` exports `createSlackClient` and `SlackClient`.
  </verify>
  <done>Config validates env vars with Zod and fails fast. Slack client wrapper initializes WebClient and resolves bot user ID via auth.test(). Both modules compile and export correct types.</done>
</task>

<task type="auto">
  <name>Task 3: Block Kit message builder with urgency color coding</name>
  <files>
    src/slack/messages.ts
  </files>
  <action>
Create `src/slack/messages.ts` implementing the Block Kit message builder per locked decisions in CONTEXT.md:

1. Define `URGENCY_CONFIG` record mapping UrgencyLevel to { color (hex), emoji, label }:
   - high: "#FF0000", ":rotating_light:", "URGENT"
   - normal: "#FFA500", ":bell:", "Attention needed"
   - low: "#36A64F", ":information_source:", "FYI"

2. Export `buildQuestionMessage(params)` function that returns `{ attachments: MessageAttachment[] }`:
   - Import `KnownBlock`, `MessageAttachment`, `RichTextBlock` from `@slack/types`
   - Build blocks array:
     a. Header block: `${emoji} Claude needs your input` (plain_text)
     b. Section block (mrkdwn): `<@${userId}> *${question}*` — this triggers push notification via @mention (SLCK-04)
     c. If `context` provided: rich_text block with `rich_text_preformatted` element for code/error display (SLCK-03). Import and use `RichTextBlock` type from `@slack/types` to avoid `as KnownBlock` cast.
     d. If `options` provided: section block with numbered list `*1.* Option text\n*2.* Option text` + "Reply with a number or type a full response." (per locked decision)
     e. Divider block
   - Wrap blocks in attachment with `color` from urgency config (SLCK-02)
   - The attachment pattern (not top-level blocks) is REQUIRED for color bar — per research anti-pattern warning

3. Export `buildTimeoutMessage()` function returning blocks for "Timed out" thread notice:
   - Full standalone message (not subtle context block — per locked decision)
   - Text: "⏱ *Timed out.* Claude will attempt to continue without an answer."

4. Export `buildStillWaitingMessage()` for the "still waiting" bump:
   - Gentle nudge tone (per CONTEXT.md specific idea)
   - Text: "⏳ Still waiting for your reply..."

5. Export `buildResponseReceivedMessage()` for confirmation:
   - Text: "✅ Response received — answer delivered to Claude."

All message builders return objects compatible with `client.chat.postMessage()` params. Use strict TypeScript types — no `as any` casts.
  </action>
  <verify>
Run `npx tsc --noEmit` — compiles with zero errors. Grep for `console.log` in src/ — zero matches. Grep for `as any` in src/ — zero matches. Verify `buildQuestionMessage` returns an object with `attachments` array containing `color` and `blocks` fields.
  </verify>
  <done>Block Kit builder produces color-coded attachment messages for all three urgency levels. Messages @mention configured user. Code context renders in rich_text_preformatted. Options render as numbered list. Timeout/waiting/received notices are standalone thread messages. Zero console.log calls. Zero `as any` casts.</done>
</task>

</tasks>

<verification>
1. `npm install && npx tsc --noEmit` passes with zero errors
2. `grep -r "console\.log" src/` returns zero matches
3. `grep -r "as any" src/` returns zero matches
4. All three urgency levels produce different color hex codes in attachment output
5. Message with userId produces `<@USERID>` mention syntax
6. Message with context produces rich_text_preformatted block
7. Message with options produces numbered list section
</verification>

<success_criteria>
- Project scaffold compiles and all dependencies are installed
- Config module validates SLACK_BOT_TOKEN, SLACK_CHANNEL_ID, SLACK_USER_ID via Zod
- Slack client creates WebClient and resolves bot user ID
- Block Kit builder produces color-coded messages for high/normal/low urgency
- All code uses strict TypeScript types with zero `as any` casts
- Zero `console.log` calls anywhere in src/
</success_criteria>

<output>
After completion, create `.planning/phases/01-slack-infrastructure-and-mcp-tool/01-01-SUMMARY.md`
</output>
