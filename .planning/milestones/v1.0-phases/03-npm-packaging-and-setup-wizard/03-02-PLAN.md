---
phase: 03-npm-packaging-and-setup-wizard
plan: 02
type: execute
wave: 2
depends_on:
  - 03-01
files_modified:
  - src/cli.ts
  - src/commands/setup.ts
  - src/commands/test.ts
  - src/commands/status.ts
  - src/wizard/prompts.ts
  - src/wizard/config-writer.ts
  - src/wizard/validator.ts
autonomous: true
requirements:
  - PKG-02

must_haves:
  truths:
    - "Running signal-flare setup prompts for Slack token, channel ID, user ID, scope, and env file path"
    - "After setup completes, ~/.claude/settings.json contains Signal Flare hook entries and ~/.claude.json contains the MCP server entry"
    - "Setup wizard validates the Slack token via auth.test() and channel via conversations.info() before writing config"
    - "Setup merges into existing settings.json and .claude.json without overwriting other tools' config"
    - "signal-flare test sends a test notification to Slack and confirms success"
    - "signal-flare status shows current env vars (masked), config file paths, and Claude Code settings state"
  artifacts:
    - path: "src/commands/setup.ts"
      provides: "Setup wizard orchestration"
      min_lines: 50
    - path: "src/commands/test.ts"
      provides: "Test notification command"
      min_lines: 20
    - path: "src/commands/status.ts"
      provides: "Configuration status display"
      min_lines: 30
    - path: "src/wizard/prompts.ts"
      provides: "Interactive prompt functions using @inquirer/prompts"
      contains: "@inquirer/prompts"
    - path: "src/wizard/config-writer.ts"
      provides: "Safe JSON merge for settings.json and .claude.json"
      min_lines: 60
    - path: "src/wizard/validator.ts"
      provides: "Slack token and channel validation"
      contains: "auth.test"
  key_links:
    - from: "src/commands/setup.ts"
      to: "src/wizard/prompts.ts"
      via: "import prompt functions"
      pattern: "promptFor"
    - from: "src/commands/setup.ts"
      to: "src/wizard/config-writer.ts"
      via: "write config after validation"
      pattern: "writeHooksConfig|writeMcpConfig"
    - from: "src/commands/setup.ts"
      to: "src/wizard/validator.ts"
      via: "validate token before writing"
      pattern: "validateSlackCredentials"
    - from: "src/wizard/config-writer.ts"
      to: "~/.claude/settings.json"
      via: "read-modify-write hooks"
      pattern: "settings\\.json"
    - from: "src/wizard/config-writer.ts"
      to: "~/.claude.json"
      via: "read-modify-write MCP servers"
      pattern: "\\.claude\\.json"
---

<objective>
Setup wizard and CLI commands: interactive setup that writes Claude Code configuration, test command for verification, and status command for debugging.

Purpose: This is the user's first experience with Signal Flare. The wizard must feel like `npx create-next-app` -- guided, validating, and zero manual file editing. The test and status commands are essential debugging tools.
Output: Three working CLI commands (setup, test, status) with full wizard flow writing to both Claude Code config files.
</objective>

<execution_context>
@/Users/jdlnolen/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jdlnolen/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-npm-packaging-and-setup-wizard/03-RESEARCH.md
@.planning/phases/03-npm-packaging-and-setup-wizard/03-01-SUMMARY.md

@src/cli.ts
@src/config.ts
@src/slack/client.ts
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create wizard utilities (prompts, validator, config-writer)</name>
  <files>
    src/wizard/prompts.ts
    src/wizard/validator.ts
    src/wizard/config-writer.ts
  </files>
  <action>
**src/wizard/prompts.ts** -- Interactive prompt functions using @inquirer/prompts:

1. Import `input`, `password`, `select`, `confirm` from `@inquirer/prompts`
2. Implement these exported async functions:
   - `promptForToken(existing?: string): Promise<string>` -- uses `password` prompt with mask '*', message "Enter your Slack Bot Token (xoxb-...):", validates starts with 'xoxb-'. If `existing` is provided, show hint "(current: xoxb-****...{last4})" in the message.
   - `promptForChannelId(existing?: string): Promise<string>` -- uses `input` prompt, validates starts with 'C', default is existing value if provided.
   - `promptForUserId(existing?: string): Promise<string>` -- uses `input` prompt, message includes "(optional, press Enter to skip)", validates starts with 'U' or is empty string, default is existing.
   - `promptForScope(): Promise<'global' | 'project'>` -- uses `select` prompt with two choices: "Global (all Claude Code sessions)" = 'global', "Project (this directory only)" = 'project'.
   - `promptForEnvPath(defaultPath: string): Promise<string>` -- uses `input` prompt, message "Where should Signal Flare store your credentials?", default is the provided defaultPath.
3. At the top of the file, check `process.stdin.isTTY` -- if false, print error "signal-flare setup requires an interactive terminal. Run without piping." and exit(1). Do this in a guard function `ensureTTY()` that each prompt function calls, or export it for the setup command to call once at start.

**src/wizard/validator.ts** -- Slack API validation:

1. Import `WebClient` from `@slack/web-api`
2. Export `async function validateSlackCredentials(token: string, channelId: string): Promise<{ valid: boolean; botName?: string; channelName?: string; error?: string }>`
   - Create a temporary `WebClient` with the token
   - Call `auth.test()` -- if it fails, return `{ valid: false, error: "Invalid token: ..." }`
   - Call `conversations.info({ channel: channelId })` -- if it fails, return `{ valid: false, error: "Invalid channel: ..." }`. Common error: `channel_not_found` means bot is not in the channel or channel ID is wrong.
   - If both succeed, return `{ valid: true, botName: authResult.user, channelName: channelResult.channel?.name }`
   - Wrap everything in try/catch for network errors

**src/wizard/config-writer.ts** -- Safe JSON merge for Claude Code config:

1. Import `readFileSync`, `writeFileSync`, `existsSync`, `mkdirSync` from 'node:fs'
2. Import `path` from 'node:path'
3. Import `homedir` from 'node:os'

4. Helper `readJsonSafe(filePath: string): Record<string, unknown>` -- returns {} if file doesn't exist, wraps JSON.parse in try/catch, returns {} if malformed (log warning).

5. Export `function resolvePackagePaths(): { serverJs: string; hookHandlerJs: string }`:
   - Use `import.meta.url` to resolve from cli.ts location to package root
   - Derive absolute paths to `dist/server.js` and `dist/hook-handler.js`
   - These are the absolute paths written into Claude Code config

6. Export `function writeEnvFile(envPath: string, vars: { token: string; channelId: string; userId?: string }): void`:
   - Create parent directory with mkdirSync recursive
   - Write .env content: `SLACK_BOT_TOKEN=`, `SLACK_CHANNEL_ID=`, optionally `SLACK_USER_ID=`
   - Use `{ mode: 0o600 }` for file permissions (owner read/write only -- security)

7. Export `function writeConfigJson(envFilePath: string): void`:
   - Write `~/.config/signal-flare/config.json` with `{ "envFile": envFilePath }` (the convention file for hook handlers)
   - Create parent directory with mkdirSync recursive

8. Export `function writeHooksConfig(scope: 'global' | 'project', hookHandlerPath: string, envFilePath: string): void`:
   - Determine target: global = `~/.claude/settings.json`, project = `.claude/settings.json`
   - Read existing JSON safely
   - Merge Signal Flare hooks into the `hooks` object. For each event type (Stop, PostToolUseFailure, PermissionRequest):
     - The hook command should be: `SIGNAL_FLARE_ENV_FILE=${envFilePath} ${hookHandlerPath}` (inline env var in command string so hook handler can find the .env)
     - Stop and PostToolUseFailure: `async: true` (non-blocking)
     - PermissionRequest: matcher should be `".*"` (fires on all permission requests; the handler itself filters for AskUserQuestion)
     - Before adding, check if Signal Flare is already registered (search for signal-flare in existing hook commands) -- if found, update in place rather than duplicating (idempotent)
   - Write merged JSON back with 2-space indent

9. Export `function writeMcpConfig(scope: 'global' | 'project', serverJsPath: string, envFilePath: string): void`:
   - Determine target: global = `~/.claude.json`, project = `.mcp.json`
   - Read existing JSON safely
   - Add/update `mcpServers.signal-flare` entry with `type: "stdio"`, `command: serverJsPath`, `args: []`, `env: { SIGNAL_FLARE_ENV_FILE: envFilePath }`
   - Write merged JSON back with 2-space indent
  </action>
  <verify>
Run `npm run build` and `npm run typecheck` -- both should succeed. All three files should compile without errors. No runtime test yet (wizard integration tested in Task 2).
  </verify>
  <done>Three wizard utility modules exist: prompts.ts (5 prompt functions + TTY guard), validator.ts (auth.test + conversations.info validation), config-writer.ts (env file writer, config.json writer, hooks config merger, MCP config merger with idempotent merge logic)</done>
</task>

<task type="auto">
  <name>Task 2: Implement setup, test, and status commands and wire into CLI</name>
  <files>
    src/commands/setup.ts
    src/commands/test.ts
    src/commands/status.ts
    src/cli.ts
  </files>
  <action>
**src/commands/setup.ts** -- The main setup wizard:

1. Export `async function runSetup(): Promise<void>`
2. Flow:
   a. Call `ensureTTY()` from wizard/prompts.ts
   b. Print welcome banner: "Signal Flare Setup" with brief description
   c. Detect existing env vars from process.env (SLACK_BOT_TOKEN, SLACK_CHANNEL_ID, SLACK_USER_ID) for pre-filling
   d. Prompt for scope (global vs project) using `promptForScope()`
   e. Prompt for Slack bot token using `promptForToken()`, pre-fill if env var exists
   f. Prompt for channel ID using `promptForChannelId()`, pre-fill if env var exists
   g. Prompt for user ID using `promptForUserId()`, pre-fill if env var exists
   h. Print "Validating Slack credentials..." and call `validateSlackCredentials(token, channelId)`
   i. If validation fails, print the error in red (use ANSI codes or just clear text) and exit(1)
   j. If valid, print success: "Connected as @{botName} to #{channelName}"
   k. Determine default env path: `~/.config/signal-flare/.env`
   l. Prompt for env file path using `promptForEnvPath(defaultPath)`
   m. Resolve absolute paths to dist/server.js and dist/hook-handler.js using `resolvePackagePaths()`
   n. Write .env file using `writeEnvFile()`
   o. Write config.json convention file using `writeConfigJson()`
   p. Write hooks config using `writeHooksConfig()`
   q. Write MCP config using `writeMcpConfig()`
   r. Print success summary:
      - ".env written to {path}"
      - "Hooks configured in {settings path}"
      - "MCP server configured in {mcp path}"
      - "Restart Claude Code to activate Signal Flare"
      - "Run `signal-flare test` to verify your setup"

**src/commands/test.ts** -- Test notification:

1. Export `async function runTest(): Promise<void>`
2. Flow:
   a. Load config using `loadConfig()` from config.ts (this will use dotenv loading)
   b. Create a direct Slack client using `createSlackClientDirect(config)` (imported from slack/client.ts)
   c. Send a test message to the configured channel: use `slackClient.client.chat.postMessage()` with a simple Block Kit message: section text "Signal Flare test notification -- your setup is working!" with a green (#36a64f) attachment color bar
   d. If success, print "Test notification sent to Slack! Check your channel."
   e. If failure, print the error and suggest checking token/channel config

**src/commands/status.ts** -- Configuration status:

1. Export `async function runStatus(): Promise<void>`
2. Flow:
   a. Print "Signal Flare Status" header
   b. Check environment variables section:
      - Show SLACK_BOT_TOKEN: set/not set (if set, show first 8 chars + "..." for masking)
      - Show SLACK_CHANNEL_ID: set/not set (show full value if set)
      - Show SLACK_USER_ID: set/not set (show full value if set)
      - Show SIGNAL_FLARE_ENV_FILE: set/not set (show path if set)
   c. Check config.json convention file:
      - Read `~/.config/signal-flare/config.json`, show envFile path if exists
      - Show whether the referenced .env file exists
   d. Check Claude Code settings:
      - Read `~/.claude/settings.json`, check if hooks contain signal-flare entries
      - Read `~/.claude.json`, check if mcpServers contains signal-flare entry
      - For each: show "Configured" or "Not configured"
   e. If nothing is configured, suggest: "Run `signal-flare setup` to get started"

**Update src/cli.ts:**
- Replace placeholder command actions with real imports:
  - `import { runSetup } from './commands/setup.js'`
  - `import { runTest } from './commands/test.js'`
  - `import { runStatus } from './commands/status.js'`
- Wire each command's `.action()` to the real function

Note: All three command files can freely use `console.log()` since they are CLI commands, not MCP server or hook handler code paths.
  </action>
  <verify>
Run `npm run build` and `npm run typecheck` -- both succeed. Run `node dist/cli.js status` -- should show status output (likely "Not configured" for everything in a fresh environment). Run `node dist/cli.js --help` -- should show all three commands. Verify `node dist/cli.js setup --help` shows the setup command description.
  </verify>
  <done>All three CLI commands implemented and wired into cli.ts. Setup wizard prompts for all values, validates via Slack API, writes .env + config.json + hooks settings + MCP config with safe merge. Test command sends a real Slack notification. Status command shows full configuration state with masked tokens.</done>
</task>

</tasks>

<verification>
1. `npm run build` and `npm run typecheck` pass
2. `node dist/cli.js --help` shows setup, test, status
3. `node dist/cli.js status` runs without errors, shows config state
4. All wizard utility files exist: src/wizard/prompts.ts, src/wizard/validator.ts, src/wizard/config-writer.ts
5. All command files exist: src/commands/setup.ts, src/commands/test.ts, src/commands/status.ts
6. config-writer.ts uses readJsonSafe for merge safety and mode 0o600 for .env file permissions
</verification>

<success_criteria>
- Setup wizard guides user through token, channel, scope, and env path configuration
- Wizard validates Slack credentials before writing any config
- Hooks written to ~/.claude/settings.json (or .claude/settings.json for project scope) with safe merge
- MCP server written to ~/.claude.json (or .mcp.json for project scope) with safe merge
- .env file written with restrictive permissions (0o600)
- Convention config.json written for hook handler env discovery
- Test command sends a real Slack notification
- Status command shows comprehensive config state
</success_criteria>

<output>
After completion, create `.planning/phases/03-npm-packaging-and-setup-wizard/03-02-SUMMARY.md`
</output>
