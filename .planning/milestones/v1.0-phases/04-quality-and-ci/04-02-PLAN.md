---
phase: 04-quality-and-ci
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/config.test.ts
  - src/slack/messages.test.ts
  - src/hooks/router.test.ts
  - src/hooks/stop.test.ts
  - src/hooks/post-tool-failure.test.ts
  - src/hooks/permission.test.ts
autonomous: true
requirements:
  - PKG-06

must_haves:
  truths:
    - "Config tests verify required env vars are validated and defaults are applied"
    - "Message builder tests verify Block Kit structure for all message types (question, hook notifications)"
    - "Hook router tests verify correct dispatch for Stop, PostToolUseFailure, and PermissionRequest events"
    - "Individual hook handler tests verify message extraction and Slack posting"
  artifacts:
    - path: "src/config.test.ts"
      provides: "Config validation tests"
      contains: "describe.*loadConfig"
    - path: "src/slack/messages.test.ts"
      provides: "Block Kit message builder tests"
      contains: "describe.*buildQuestionMessage"
    - path: "src/hooks/router.test.ts"
      provides: "Hook event routing tests"
      contains: "describe.*routeHookEvent"
    - path: "src/hooks/stop.test.ts"
      provides: "Stop handler tests"
      contains: "describe.*handleStop"
    - path: "src/hooks/post-tool-failure.test.ts"
      provides: "PostToolUseFailure handler tests"
      contains: "describe.*handlePostToolFailure"
    - path: "src/hooks/permission.test.ts"
      provides: "Permission handler tests"
      contains: "describe.*handlePermission"
  key_links:
    - from: "src/config.test.ts"
      to: "src/config.ts"
      via: "import loadConfig"
      pattern: "import.*from.*./config"
    - from: "src/hooks/router.test.ts"
      to: "src/hooks/router.ts"
      via: "import routeHookEvent"
      pattern: "import.*from.*./router"
---

<objective>
Write comprehensive unit tests for the pure/simpler modules: config validation, Block Kit message builders, and all four hook handlers (router, stop, post-tool-failure, permission).

Purpose: Cover the business logic layer that transforms inputs to outputs without complex async dependencies. These modules are ideal for dense, fast-running unit tests.
Output: 6 colocated test files with thorough coverage of config validation, message formatting, and hook event handling.
</objective>

<execution_context>
@/Users/jdlnolen/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jdlnolen/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-quality-and-ci/04-RESEARCH.md
@.planning/phases/04-quality-and-ci/04-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write tests for config and message builders</name>
  <files>
    src/config.test.ts
    src/slack/messages.test.ts
  </files>
  <action>
**src/config.test.ts** — Test the `loadConfig` function:
- Read `src/config.ts` first to understand the exact Zod schema, defaults, and error behavior.
- Use `vi.resetModules()` + dynamic `import('./config.js')` pattern to test env var combinations (per research pattern).
- Test cases:
  - Valid config with all required vars → returns parsed config with correct types
  - Missing SLACK_BOT_TOKEN → fails (process.exit or throws — match actual behavior)
  - Missing SLACK_CHANNEL_ID → fails
  - Optional SLACK_USER_ID absent → config has undefined for that field
  - Default values applied: POLL_TIMEOUT_MS, HOOK_IDLE_TIMEOUT_MS, SEND_DELAY_MS (verify actual default values from source)
  - Custom numeric env vars override defaults (e.g., POLL_TIMEOUT_MS=300000)
- Save/restore `process.env` in beforeEach/afterEach.

**src/slack/messages.test.ts** — Test all message builder functions:
- Read `src/slack/messages.ts` first to see all exported functions and their signatures.
- For `buildQuestionMessage`:
  - Normal question → has header, question text in section, urgency color attachment
  - With userId → includes `<@userId>` mention
  - Without userId → no mention block
  - Each urgency level (high/normal/low) → correct color hex
  - With context (file path, code snippet) → context appears in message
  - With options → options listed
- For hook notification builders (buildHookMessage or similar):
  - Stop event → COMPLETED header, summary text, orange color
  - Error event → ERROR header, error text and tool name
  - Question event → QUESTION header, question text
- Verify Block Kit structure: check that returned objects have `channel`, `attachments` array, blocks within attachments, correct `color` field.
- Use plain `expect()` assertions — no mocks needed (pure functions).
  </action>
  <verify>
Run `npx vitest run src/config.test.ts src/slack/messages.test.ts` — all tests pass.
Run `npx vitest run --coverage src/config.test.ts src/slack/messages.test.ts` — check coverage for config.ts and messages.ts.
  </verify>
  <done>config.test.ts covers all validation paths and defaults. messages.test.ts covers all message builder functions with urgency levels, mentions, and Block Kit structure verification.</done>
</task>

<task type="auto">
  <name>Task 2: Write tests for hook router and all hook handlers</name>
  <files>
    src/hooks/router.test.ts
    src/hooks/stop.test.ts
    src/hooks/post-tool-failure.test.ts
    src/hooks/permission.test.ts
  </files>
  <action>
Read each source file before writing its test: `src/hooks/router.ts`, `src/hooks/stop.ts`, `src/hooks/post-tool-failure.ts`, `src/hooks/permission.ts`.

**src/hooks/router.test.ts** — Test `routeHookEvent` dispatch:
- Mock the individual handler modules (`./stop.js`, `./post-tool-failure.js`, `./permission.js`) using `vi.mock`.
- Test that Stop event dispatches to handleStop.
- Test that PostToolUseFailure event dispatches to handlePostToolFailure.
- Test that PreToolUse (PermissionRequest) event dispatches to handlePermission.
- Test that unknown event name is handled gracefully (no crash, logs warning).
- Verify each handler is called with the correct arguments (event data, slack client, config).

**src/hooks/stop.test.ts** — Test `handleStop`:
- Mock `@slack/web-api` WebClient (or accept a mock slack client object).
- Test: receives stop event with assistant message → calls chat.postMessage with COMPLETED notification containing extracted summary.
- Test: `extractSummary` extracts first sentence, truncates to 200 chars (per Phase 2 decision).
- Test: `stop_hook_active` guard prevents infinite loop (if applicable — check source).
- Test: Slack API error → logs to stderr, does not throw.

**src/hooks/post-tool-failure.test.ts** — Test `handlePostToolFailure`:
- Test: receives error event → calls chat.postMessage with ERROR notification containing tool name and error text.
- Test: missing tool name → handles gracefully.
- Test: Slack API error → logs to stderr, does not throw.

**src/hooks/permission.test.ts** — Test `handlePermission`:
- Test: AskUserQuestion tool detected (via `isAskHuman` which uses `.includes('ask_human_via_slack')`) → sends notification, spawns watcher.
- Test: Non-AskUserQuestion tool → no notification sent (handler returns early).
- Test: Question text and options extracted correctly from tool input.
- Mock `child_process.spawn` for watcher spawn verification (or mock the spawnWatcher function if it's a separate export).
- Test: Slack API error → logs to stderr, does not throw.

IMPORTANT ESM mock patterns:
- Use `vi.mock('./module.js')` with `.js` extension (Node16 resolution).
- Use inline `vi.fn()` inside mock factories, or `vi.hoisted()` for pre-defined mocks.
- Use `vi.clearAllMocks()` in `beforeEach`.
  </action>
  <verify>
Run `npx vitest run src/hooks/` — all hook tests pass.
Run `npx vitest run --coverage src/hooks/ src/config.test.ts src/slack/messages.test.ts` — check coverage across all tested modules.
  </verify>
  <done>Hook router correctly dispatches to handlers for all event types. Each handler test covers happy path, error extraction, Slack API failure resilience, and edge cases. All tests pass.</done>
</task>

</tasks>

<verification>
1. `npx vitest run` — all tests in this plan pass
2. `npm run lint` — new test files pass lint (no-explicit-any relaxed for test files)
3. Coverage for config.ts, messages.ts, router.ts, stop.ts, post-tool-failure.ts, permission.ts is well above 80%
</verification>

<success_criteria>
Six colocated test files exist and pass. Config validation, message builders, and all hook handlers have comprehensive test coverage including error paths and edge cases.
</success_criteria>

<output>
After completion, create `.planning/phases/04-quality-and-ci/04-02-SUMMARY.md`
</output>
