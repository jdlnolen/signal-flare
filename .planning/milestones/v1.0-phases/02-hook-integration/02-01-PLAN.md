---
phase: 02-hook-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types.ts
  - src/config.ts
  - src/slack/client.ts
  - src/slack/messages.ts
  - tsup.config.ts
autonomous: true
requirements:
  - HOOK-01
  - HOOK-02
  - HOOK-03
  - HOOK-04

must_haves:
  truths:
    - "Hook input JSON from Claude Code can be validated with Zod schemas for all three event types"
    - "Hook handler can create a Slack client without the auth.test() round-trip"
    - "Hook notifications use a unified Block Kit layout with type labels (COMPLETED, ERROR, QUESTION, PERMISSION)"
    - "Build produces both dist/server.js and dist/hook-handler.js entry points"
  artifacts:
    - path: "src/types.ts"
      provides: "Zod schemas and inferred types for StopHookInput, PostToolUseFailureInput, PermissionRequestInput"
      contains: "StopHookInput"
    - path: "src/config.ts"
      provides: "HOOK_IDLE_TIMEOUT_MS env var with 90000 default"
      contains: "HOOK_IDLE_TIMEOUT_MS"
    - path: "src/slack/client.ts"
      provides: "createSlackClientDirect() factory that skips auth.test()"
      exports: ["createSlackClient", "createSlackClientDirect"]
    - path: "src/slack/messages.ts"
      provides: "buildHookMessage() builder for all hook notification types"
      contains: "buildHookMessage"
    - path: "tsup.config.ts"
      provides: "Multi-entry build with server.ts, hook-handler.ts, and hooks/watcher.ts"
      contains: "hook-handler"
  key_links:
    - from: "src/types.ts"
      to: "Claude Code hooks API"
      via: "Zod schemas matching hook stdin JSON shape"
      pattern: "StopHookInputSchema"
    - from: "src/slack/messages.ts"
      to: "src/types.ts"
      via: "HookNotificationType used in buildHookMessage"
      pattern: "buildHookMessage"
    - from: "src/slack/client.ts"
      to: "src/config.ts"
      via: "createSlackClientDirect reads config without auth.test()"
      pattern: "createSlackClientDirect"
---

<objective>
Extend Phase 1 infrastructure to support hook integration: add hook input type schemas, lightweight Slack client factory, unified Block Kit message builder for hook notifications, HOOK_IDLE_TIMEOUT_MS config, and multi-entry build configuration.

Purpose: All three hook handlers (Stop, PostToolUseFailure, PermissionRequest) depend on shared types, a fast Slack client, and a unified message builder. This plan creates those foundations so Plan 02 can focus purely on handler logic.
Output: Extended types.ts, config.ts, client.ts, messages.ts, and updated tsup.config.ts ready for hook handler implementation.
</objective>

<execution_context>
@/Users/jdlnolen/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jdlnolen/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-hook-integration/02-CONTEXT.md
@.planning/phases/02-hook-integration/02-RESEARCH.md
@src/types.ts
@src/config.ts
@src/slack/client.ts
@src/slack/messages.ts
@tsup.config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add hook input Zod schemas, config extension, and lightweight Slack client</name>
  <files>src/types.ts, src/config.ts, src/slack/client.ts</files>
  <action>
**src/types.ts** — Add Zod schemas and inferred types for all three hook event inputs. Keep existing types untouched. Add at the bottom of the file:

1. Import `z` from "zod" at the top of the file.
2. Define `StopHookInputSchema` as a z.object matching the Stop hook input from Claude Code:
   - `session_id: z.string()`
   - `transcript_path: z.string()`
   - `cwd: z.string()`
   - `permission_mode: z.string()`
   - `hook_event_name: z.literal("Stop")`
   - `stop_hook_active: z.boolean()`
   - `last_assistant_message: z.string()`
3. Define `PostToolUseFailureInputSchema` as a z.object:
   - `session_id: z.string()`
   - `transcript_path: z.string()`
   - `cwd: z.string()`
   - `permission_mode: z.string()`
   - `hook_event_name: z.literal("PostToolUseFailure")`
   - `tool_name: z.string()`
   - `tool_input: z.record(z.unknown())`
   - `tool_use_id: z.string()`
   - `error: z.string()`
   - `is_interrupt: z.boolean().optional()`
4. Define `PermissionRequestInputSchema` as a z.object:
   - `session_id: z.string()`
   - `transcript_path: z.string()`
   - `cwd: z.string()`
   - `permission_mode: z.string()`
   - `hook_event_name: z.literal("PermissionRequest")`
   - `tool_name: z.string()`
   - `tool_input: z.record(z.unknown())`
   - `permission_suggestions: z.array(z.object({ type: z.string(), tool: z.string() })).optional()`
5. Export inferred types: `StopHookInput`, `PostToolUseFailureInput`, `PermissionRequestInput` using `z.infer<>`.
6. Define and export a `HookNotificationType` type literal union: `"COMPLETED" | "ERROR" | "QUESTION" | "PERMISSION"`.
7. Define and export a discriminated union schema `HookInputSchema` using `z.discriminatedUnion("hook_event_name", [StopHookInputSchema, PostToolUseFailureInputSchema, PermissionRequestInputSchema])` and its inferred type `HookInput`.

**src/config.ts** — Add `HOOK_IDLE_TIMEOUT_MS` to the existing ConfigSchema:
- `HOOK_IDLE_TIMEOUT_MS: z.coerce.number().int().min(0).default(90000)` — 90 seconds default, configurable via env var.
- Update the error help text in `loadConfig()` to include the new optional variable.

**src/slack/client.ts** — Add a `createSlackClientDirect()` factory function that skips `auth.test()`:
- Accepts `config: Config` parameter.
- Creates `WebClient` with `config.SLACK_BOT_TOKEN`.
- Returns a `SlackClient` with `botUserId` set to empty string `""` (hook handler never polls, so bot filtering is not needed).
- Export both `createSlackClient` (existing, unchanged) and `createSlackClientDirect` (new).
- This avoids the 100-500ms `auth.test()` round-trip on every hook invocation per the research pitfall analysis.
  </action>
  <verify>Run `npx tsc --noEmit` — no type errors. Verify the new Zod schemas parse sample hook JSON correctly by inspecting the type inference.</verify>
  <done>types.ts exports StopHookInputSchema, PostToolUseFailureInputSchema, PermissionRequestInputSchema, HookInputSchema, HookNotificationType, and all inferred types. config.ts includes HOOK_IDLE_TIMEOUT_MS with 90000 default. client.ts exports createSlackClientDirect that returns a SlackClient without calling auth.test().</done>
</task>

<task type="auto">
  <name>Task 2: Add unified hook message builder and update build configuration</name>
  <files>src/slack/messages.ts, tsup.config.ts</files>
  <action>
**src/slack/messages.ts** — Add `buildHookMessage()` function that creates a unified Block Kit layout for all hook notification types. Per locked decision: same structure as Phase 1 messages, differentiated by a text label — NOT distinct color bars per type.

1. Add a new exported function `buildHookMessage(opts: HookMessageOptions)` where `HookMessageOptions` is:
   ```
   interface HookMessageOptions {
     label: HookNotificationType;  // "COMPLETED", "ERROR", "QUESTION", "PERMISSION"
     headline: string;             // Main summary text
     body?: string;                // Optional detailed body (context, error text, etc.)
     context?: string;             // Optional code/file context for rich_text_preformatted
     userId?: string;              // Optional @mention
   }
   ```
   Import `HookNotificationType` from `../types.js`.

2. The function returns `{ attachments: MessageAttachment[] }` using the same attachment wrapper pattern as `buildQuestionMessage()` for color bar display.

3. Message structure (inside attachment blocks array):
   - **Header block:** Label emoji + label text. Map labels to emojis: COMPLETED = ":white_check_mark: Task Completed", ERROR = ":x: Tool Error", QUESTION = ":bell: Claude needs your input", PERMISSION = ":lock: Permission Needed". Use HeaderBlock type.
   - **Section block:** `@mention headline` as mrkdwn. Bold the headline: `*${headline}*`. Include `<@${userId}>` prefix if userId provided.
   - **Rich text preformatted block** (only if `context` provided): Same pattern as existing `buildQuestionMessage` — RichTextBlock with RichTextPreformatted element containing the context string.
   - **Section block** (only if `body` provided): Plain mrkdwn section with body text. Used for numbered options in QUESTION type or action details in PERMISSION type.
   - **Divider block** at the end.

4. Use the "normal" urgency color (`#FFA500` orange) for ALL hook notification types per locked decision ("not distinct color bars per type").

5. Also add a `buildResolvedInTerminalMessage()` function that returns `{ text: string }` with content: `"✅ Resolved in terminal — no action needed."` — used by the watcher when terminal response is detected.

**tsup.config.ts** — Update entry array to include all three entry points:
```typescript
entry: [
  "src/server.ts",
  "src/hook-handler.ts",
  "src/hooks/watcher.ts",
],
```
The `hook-handler.ts` and `hooks/watcher.ts` files don't exist yet (created in Plan 02), but tsup will only fail at build time, not config time. This is fine — the build will succeed once Plan 02 creates those files.

IMPORTANT: Do NOT add the shebang `banner` to watcher.ts — only server.ts and hook-handler.ts need it. Since tsup's banner applies to all entries, either: (a) remove the banner config and add shebangs manually in the source files via a comment, or (b) keep the banner (it's harmless on watcher.ts since it's spawned via `node` explicitly). Option (b) is simpler — keep the existing banner config unchanged.
  </action>
  <verify>Run `npx tsc --noEmit` — no type errors. Verify `buildHookMessage` is exported from messages.ts. Check tsup.config.ts has all three entry points.</verify>
  <done>messages.ts exports buildHookMessage() with unified Block Kit layout supporting COMPLETED/ERROR/QUESTION/PERMISSION labels, plus buildResolvedInTerminalMessage(). tsup.config.ts builds server.ts, hook-handler.ts, and hooks/watcher.ts as entry points.</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with zero errors
- `src/types.ts` exports all three hook input Zod schemas + discriminated union + HookNotificationType
- `src/config.ts` ConfigSchema includes HOOK_IDLE_TIMEOUT_MS with default 90000
- `src/slack/client.ts` exports both createSlackClient and createSlackClientDirect
- `src/slack/messages.ts` exports buildHookMessage and buildResolvedInTerminalMessage
- `tsup.config.ts` entry array contains server.ts, hook-handler.ts, hooks/watcher.ts
- No console.log() calls in any modified file
</verification>

<success_criteria>
All hook infrastructure is in place: validated input types, fast Slack client, unified message builder, and multi-entry build config. Plan 02 can focus solely on hook handler logic without touching any shared infrastructure files.
</success_criteria>

<output>
After completion, create `.planning/phases/02-hook-integration/02-01-SUMMARY.md`
</output>
