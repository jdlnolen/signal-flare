---
phase: 02-hook-integration
plan: 02
type: execute
wave: 2
depends_on:
  - 02-01
files_modified:
  - src/hook-handler.ts
  - src/hooks/router.ts
  - src/hooks/stop.ts
  - src/hooks/post-tool-failure.ts
  - src/hooks/permission.ts
  - src/hooks/watcher.ts
autonomous: true
requirements:
  - HOOK-01
  - HOOK-02
  - HOOK-03
  - HOOK-04

must_haves:
  truths:
    - "When Claude Code session ends, a COMPLETED notification appears in Slack with a summary of the last assistant message"
    - "When Claude Code encounters a tool error, an ERROR notification appears in Slack with tool name, error text, and context"
    - "When Claude calls AskUserQuestion, a QUESTION notification fires to Slack with full question text and numbered options"
    - "When Claude requests any other permission, a PERMISSION notification fires to Slack with tool name and action description"
    - "Hook handler exits immediately after sending notification — never blocks Claude Code"
    - "For questions/permissions, a detached background watcher monitors for terminal response and posts 'resolved in terminal' thread reply within 90s window"
  artifacts:
    - path: "src/hook-handler.ts"
      provides: "Hook entry point — reads stdin JSON, validates, routes to handler, exits 0"
      min_lines: 20
    - path: "src/hooks/router.ts"
      provides: "Routes validated hook input to correct handler by hook_event_name"
      exports: ["routeHookEvent"]
    - path: "src/hooks/stop.ts"
      provides: "Stop hook handler — extracts summary, posts COMPLETED notification"
      exports: ["handleStop"]
    - path: "src/hooks/post-tool-failure.ts"
      provides: "PostToolUseFailure handler — posts ERROR notification with tool context"
      exports: ["handlePostToolUseFailure"]
    - path: "src/hooks/permission.ts"
      provides: "PermissionRequest handler — QUESTION for AskUserQuestion, PERMISSION for others, spawns watcher"
      exports: ["handlePermissionRequest"]
    - path: "src/hooks/watcher.ts"
      provides: "Detached background watcher entry point — polls transcript for terminal response"
      min_lines: 40
  key_links:
    - from: "src/hook-handler.ts"
      to: "src/hooks/router.ts"
      via: "routeHookEvent(input, slackClient, config)"
      pattern: "routeHookEvent"
    - from: "src/hooks/router.ts"
      to: "src/hooks/stop.ts"
      via: "handleStop import and dispatch on Stop event"
      pattern: "handleStop"
    - from: "src/hooks/router.ts"
      to: "src/hooks/post-tool-failure.ts"
      via: "handlePostToolUseFailure import and dispatch on PostToolUseFailure event"
      pattern: "handlePostToolUseFailure"
    - from: "src/hooks/router.ts"
      to: "src/hooks/permission.ts"
      via: "handlePermissionRequest import and dispatch on PermissionRequest event"
      pattern: "handlePermissionRequest"
    - from: "src/hooks/permission.ts"
      to: "src/hooks/watcher.ts"
      via: "spawnWatcher() spawns detached child process"
      pattern: "spawnWatcher"
    - from: "src/hooks/stop.ts"
      to: "src/slack/messages.ts"
      via: "buildHookMessage with label COMPLETED"
      pattern: "buildHookMessage"
    - from: "src/hooks/post-tool-failure.ts"
      to: "src/slack/messages.ts"
      via: "buildHookMessage with label ERROR"
      pattern: "buildHookMessage"
    - from: "src/hooks/permission.ts"
      to: "src/slack/messages.ts"
      via: "buildHookMessage with label QUESTION or PERMISSION"
      pattern: "buildHookMessage"
    - from: "src/hook-handler.ts"
      to: "src/slack/client.ts"
      via: "createSlackClientDirect (no auth.test() round-trip)"
      pattern: "createSlackClientDirect"
---

<objective>
Implement all hook handler logic: entry point that reads stdin JSON, router that dispatches by event type, three event handlers (Stop, PostToolUseFailure, PermissionRequest), and a detached background watcher for terminal-response detection.

Purpose: This is the core deliverable of Phase 2 — automatic Slack notifications for Claude Code events without requiring explicit MCP tool calls.
Output: Six new files in src/ that, combined with Plan 01's infrastructure, produce a working `dist/hook-handler.js` and `dist/hooks/watcher.js`.
</objective>

<execution_context>
@/Users/jdlnolen/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jdlnolen/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-hook-integration/02-CONTEXT.md
@.planning/phases/02-hook-integration/02-RESEARCH.md
@.planning/phases/02-hook-integration/02-01-SUMMARY.md
@src/types.ts
@src/config.ts
@src/slack/client.ts
@src/slack/messages.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create hook entry point, router, Stop handler, and PostToolUseFailure handler</name>
  <files>src/hook-handler.ts, src/hooks/router.ts, src/hooks/stop.ts, src/hooks/post-tool-failure.ts</files>
  <action>
**src/hook-handler.ts** — Main entry point for all Claude Code hooks. This is what `~/.claude/settings.json` points to via `node /path/to/signal-flare/dist/hook-handler.js`.

1. Add the `console.log()` ban comment at top of file.
2. Implement `readStdin(): Promise<string>` — accumulates all stdin data, resolves on 'end' event. Set encoding to 'utf8'.
3. Main IIFE `(async () => { ... })()`:
   - Call `readStdin()` to get raw JSON string.
   - `JSON.parse(raw)` the input.
   - Validate with `HookInputSchema.safeParse(parsed)` from types.ts. If validation fails, log to stderr and exit 0 (don't block Claude Code with exit 2).
   - Call `loadConfig()` from config.ts.
   - Call `createSlackClientDirect(config)` from client.ts — NOT `createSlackClient()` (avoids auth.test() latency per research pitfall).
   - Call `routeHookEvent(result.data, slackClient, config)` from router.ts.
   - `process.exit(0)` after routing completes.
4. Wrap in try-catch. On error: `console.error("[signal-flare hook] Fatal error:", err)` then `process.exit(1)`. NEVER exit with code 2 — that blocks Claude Code.
5. Zero `console.log()` calls. All logging via `console.error()`.

**src/hooks/router.ts** — Routes validated hook input to the correct handler.

1. Export `async function routeHookEvent(input: HookInput, slackClient: SlackClient, config: Config): Promise<void>`.
2. Switch on `input.hook_event_name`:
   - `"Stop"`: call `handleStop(input, slackClient, config)`
   - `"PostToolUseFailure"`: call `handlePostToolUseFailure(input, slackClient, config)`
   - `"PermissionRequest"`: call `handlePermissionRequest(input, slackClient, config)`
3. For the default case (shouldn't happen with discriminated union but defensive): log unknown event to stderr, return without error.
4. Import all handler functions and types.

**src/hooks/stop.ts** — Stop hook handler (task completion, HOOK-03).

1. Export `async function handleStop(input: StopHookInput, slackClient: SlackClient, config: Config): Promise<void>`.
2. Per locked decision: "one-line summary sentence of what Claude accomplished, extracted from last assistant message."
3. Implement `extractSummary(lastMessage: string): string`:
   - If message is empty or whitespace, return "Task completed (no summary available)".
   - Take the first sentence (split on `.`, `!`, `?` followed by space or end-of-string). If first sentence is > 200 chars, truncate to 200 chars + "...".
   - If no sentence delimiter found, take first 200 chars + "...".
4. Check `input.stop_hook_active` — if true, log a warning to stderr and return early (belt-and-suspenders to prevent infinite loop per research pitfall 5).
5. Build notification using `buildHookMessage({ label: "COMPLETED", headline: summary, userId: config.SLACK_USER_ID })`.
6. Post via `slackClient.web.chat.postMessage({ channel: slackClient.channelId, text: summary, ...payload })`.
7. Fire-and-forget: catch any Slack API error, log to stderr, do NOT throw (handler must not block Claude Code).

**src/hooks/post-tool-failure.ts** — PostToolUseFailure handler (error notification, HOOK-04).

1. Export `async function handlePostToolUseFailure(input: PostToolUseFailureInput, slackClient: SlackClient, config: Config): Promise<void>`.
2. Per locked decision: "include tool name, error text, AND file path / command context."
3. Implement `extractToolContext(toolName: string, toolInput: Record<string, unknown>): string`:
   - For `Bash`: return `toolInput.command as string` (the bash command that failed), truncated to 500 chars.
   - For `Write`, `Edit`, `Read`: return `toolInput.file_path as string` (the file path).
   - For MCP tools (name contains `mcp__`): return JSON.stringify of first 3 keys of toolInput, truncated to 300 chars.
   - Default: return `JSON.stringify(toolInput)` truncated to 300 chars.
4. Build notification:
   - `headline`: `"${toolName} failed"` (e.g., "Bash failed", "Write failed")
   - `body`: The error text (`input.error`), truncated to 1000 chars if very long.
   - `context`: The extracted tool context from step 3 (shown as preformatted code block).
   - `userId`: `config.SLACK_USER_ID`
   - `label`: `"ERROR"`
5. Post via `slackClient.web.chat.postMessage({ channel: slackClient.channelId, text: "Tool error: " + toolName, ...payload })`.
6. Fire-and-forget: catch, log, don't throw.
  </action>
  <verify>Run `npx tsc --noEmit` — no type errors. Run `npx tsup` — build succeeds and produces dist/hook-handler.js. Test manually: `echo '{"hook_event_name":"Stop","session_id":"test","transcript_path":"/tmp/test","cwd":"/tmp","permission_mode":"default","stop_hook_active":false,"last_assistant_message":"I updated the README with installation instructions."}' | SLACK_BOT_TOKEN=xoxb-test SLACK_CHANNEL_ID=C123 node dist/hook-handler.js 2>&1` — should attempt Slack post (will fail with invalid token but should show the attempt in stderr, not crash on schema validation).</verify>
  <done>hook-handler.ts reads stdin, validates with HookInputSchema, routes to handler. Stop handler extracts one-line summary and posts COMPLETED notification. PostToolUseFailure handler extracts tool context and posts ERROR notification. Build produces dist/hook-handler.js. All handlers exit immediately and never block Claude Code.</done>
</task>

<task type="auto">
  <name>Task 2: Create PermissionRequest handler and detached background watcher</name>
  <files>src/hooks/permission.ts, src/hooks/watcher.ts</files>
  <action>
**src/hooks/permission.ts** — PermissionRequest handler (HOOK-01 + HOOK-02).

Per locked decisions:
- Fires for ALL permission prompts, not just AskUserQuestion
- Every permission prompt gets its own individual notification
- AskUserQuestion: show full question text and numbered options
- Non-AskUserQuestion: show tool name + specific action requested
- Spawns detached watcher for "resolved in terminal" detection

1. Export `async function handlePermissionRequest(input: PermissionRequestInput, slackClient: SlackClient, config: Config): Promise<void>`.

2. Detect AskUserQuestion: `const isAskHuman = input.tool_name.includes("ask_human_via_slack")` — use `.includes()` not exact match, to handle `mcp__signal-flare__ask_human_via_slack` naming convention (per research pitfall 4).

3. If `isAskHuman`:
   - Extract `question` as `(input.tool_input.question as string) || "Question from Claude"`.
   - Extract `options` as `input.tool_input.options as string[] | undefined`.
   - Build body: if options exist, format as numbered list (`"1. option\n2. option\n..."` with `"\n\nReply with a number or type a full response."`).
   - Call `buildHookMessage({ label: "QUESTION", headline: question, body: bodyWithOptions, userId: config.SLACK_USER_ID })`.

4. If NOT `isAskHuman`:
   - Implement `extractActionDescription(toolName: string, toolInput: Record<string, unknown>): string`:
     - For `Bash`: `"Run: " + (toolInput.command as string || "unknown command")`, truncated to 300 chars.
     - For `Write`: `"Write to: " + (toolInput.file_path as string || "unknown file")`.
     - For `Edit`: `"Edit: " + (toolInput.file_path as string || "unknown file")`.
     - For `Read`: `"Read: " + (toolInput.file_path as string || "unknown file")`.
     - Default: `toolName + " — " + JSON.stringify(toolInput).substring(0, 200)`.
   - Call `buildHookMessage({ label: "PERMISSION", headline: "Claude wants to use: " + toolName, body: actionDescription, userId: config.SLACK_USER_ID })`.

5. Post message: `const postResult = await slackClient.web.chat.postMessage({ channel: slackClient.channelId, text: "Permission needed: " + input.tool_name, ...payload })`.

6. After posting, spawn the watcher if post succeeded and we have a thread timestamp:
   ```
   if (postResult.ok && postResult.ts) {
     spawnWatcher(input.transcript_path, postResult.ts, slackClient.channelId, config);
   }
   ```

7. Export `spawnWatcher(transcriptPath: string, threadTs: string, channelId: string, config: Config): void`:
   - Import `spawn` from `"node:child_process"` and `fileURLToPath` from `"node:url"`.
   - Resolve watcher script path: `fileURLToPath(new URL("./watcher.js", import.meta.url))`.
   - Spawn: `spawn(process.execPath, [watcherPath, transcriptPath, threadTs, channelId], { detached: true, stdio: "ignore", env: process.env })`.
   - Call `child.unref()` so parent can exit.
   - Wrap in try-catch: if spawn fails, log to stderr but do NOT throw — the notification was already sent, watcher is a best-effort enhancement.

8. Fire-and-forget pattern: wrap the entire Slack post in try-catch, log errors to stderr, never throw.

**src/hooks/watcher.ts** — Detached background watcher entry point (HOOK-02).

This file runs as a standalone Node.js process spawned by the permission handler. It is NOT imported by other modules — it is a separate entry point built by tsup.

1. Add the `console.log()` ban comment at top.
2. Read CLI args: `const [transcriptPath, threadTs, channelId] = process.argv.slice(2)`.
3. Validate args — if any missing, exit 1 silently.
4. Load config via `loadConfig()` (reads env vars — they're inherited from parent process).
5. Create Slack client via `createSlackClientDirect(config)`.
6. Record initial transcript state: read the transcript file with `readFileSync(transcriptPath, "utf8")`, count lines. If file doesn't exist or is unreadable, log to stderr and exit 0 (graceful degradation).
7. Poll loop — every 5 seconds, for up to `config.HOOK_IDLE_TIMEOUT_MS` (default 90s):
   - Read transcript file again.
   - Count current lines.
   - If line count increased, check the new lines for human messages:
     - Parse each new line as JSON (try-catch per line — skip malformed).
     - Look for messages where the `role` field is `"human"` or `"user"` (be defensive — try both field names).
     - If a human message is found after the initial line count, the user responded in terminal.
   - If terminal response detected:
     - Import `buildResolvedInTerminalMessage` from `../slack/messages.js`.
     - Post thread reply: `slackClient.web.chat.postMessage({ channel: channelId, thread_ts: threadTs, ...buildResolvedInTerminalMessage() })`.
     - Exit 0 immediately.
   - Sleep 5 seconds (`await new Promise(r => setTimeout(r, 5000))`).
8. If timeout reached (no terminal response detected within HOOK_IDLE_TIMEOUT_MS): exit 0 silently. The Slack notification stands as-is — no thread reply needed.
9. Wrap main logic in `(async () => { ... })()` with try-catch. On error, write to stderr and exit 1.
10. CRITICAL: No `console.log()` calls. The watcher's stderr is detached (`stdio: "ignore"` in spawn), so stderr logging is best-effort for debugging via log files. Consider writing critical errors to `~/.claude/signal-flare-watcher.log` using `appendFileSync` for debuggability (per research pitfall 3).
  </action>
  <verify>Run `npx tsc --noEmit` — no type errors. Run `npx tsup` — build succeeds and produces dist/hook-handler.js and dist/hooks/watcher.js. Test the full hook flow manually:
1. Stop hook: `echo '{"hook_event_name":"Stop","session_id":"s1","transcript_path":"/tmp/t.jsonl","cwd":"/tmp","permission_mode":"default","stop_hook_active":false,"last_assistant_message":"I fixed the bug in auth.ts and added tests."}' | SLACK_BOT_TOKEN=xoxb-test SLACK_CHANNEL_ID=C123 node dist/hook-handler.js 2>&1`
2. PostToolUseFailure: `echo '{"hook_event_name":"PostToolUseFailure","session_id":"s1","transcript_path":"/tmp/t.jsonl","cwd":"/tmp","permission_mode":"default","tool_name":"Bash","tool_input":{"command":"npm test"},"tool_use_id":"tu1","error":"Exit code 1: tests failed"}' | SLACK_BOT_TOKEN=xoxb-test SLACK_CHANNEL_ID=C123 node dist/hook-handler.js 2>&1`
3. PermissionRequest: `echo '{"hook_event_name":"PermissionRequest","session_id":"s1","transcript_path":"/tmp/t.jsonl","cwd":"/tmp","permission_mode":"default","tool_name":"Bash","tool_input":{"command":"rm -rf node_modules"}}' | SLACK_BOT_TOKEN=xoxb-test SLACK_CHANNEL_ID=C123 node dist/hook-handler.js 2>&1`
All three should attempt Slack API calls (will fail with invalid token) but should NOT crash on schema validation or routing.</verify>
  <done>PermissionRequest handler detects AskUserQuestion via tool_name.includes("ask_human_via_slack"), formats QUESTION or PERMISSION notification, posts to Slack, and spawns detached watcher. Watcher polls transcript file for terminal response within 90s and posts "resolved in terminal" thread reply if detected. Full hook pipeline works: stdin JSON -> validation -> routing -> handler -> Slack notification -> optional watcher. Build produces both dist/hook-handler.js and dist/hooks/watcher.js.</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with zero errors
- `npx tsup` produces dist/hook-handler.js and dist/hooks/watcher.js
- No console.log() calls in any new file
- Stop hook posts COMPLETED notification with one-line summary
- PostToolUseFailure posts ERROR notification with tool name, error, and context
- PermissionRequest posts QUESTION (for AskUserQuestion) or PERMISSION (for others)
- PermissionRequest spawns detached watcher that monitors transcript for 90s
- All handlers exit immediately — none block Claude Code
- Hook handler always exits 0 (or 1 for fatal) — never exit 2
- HookInputSchema discriminated union correctly validates all three event types
</verification>

<success_criteria>
Running `echo '<stop_json>' | node dist/hook-handler.js` posts a COMPLETED notification to Slack. Running with PostToolUseFailure JSON posts an ERROR notification. Running with PermissionRequest JSON posts a QUESTION or PERMISSION notification and spawns a background watcher process. The hook handler exits in under 2 seconds (no auth.test() delay). The watcher process runs independently for up to 90s monitoring the transcript file.
</success_criteria>

<output>
After completion, create `.planning/phases/02-hook-integration/02-02-SUMMARY.md`
</output>
