---
phase: 01-slack-infrastructure-and-mcp-tool
plan: 02
type: execute
wave: 2
depends_on:
  - 01-01
files_modified:
  - src/slack/poller.ts
  - src/tools/ask-human.ts
  - src/server.ts
autonomous: true
requirements:
  - SLCK-01
  - SLCK-05
  - SLCK-06

must_haves:
  truths:
    - "Poll manager detects human replies in Slack threads while ignoring bot messages"
    - "Polling uses exponential backoff starting at 3s with 15s cap"
    - "Short replies (single emoji, single word) are filtered out unless they are common acknowledgments"
    - "After 10-minute timeout, a still-waiting bump is posted and polling retries for another 10 minutes"
    - "After final timeout, a timed-out notice is posted and tool returns an error"
    - "MCP server starts via stdio transport and registers ask_human_via_slack tool"
    - "Tool posts Block Kit question to Slack, polls for reply, and returns structured response"
    - "Successful reply posts a response-received notice in the thread"
  artifacts:
    - path: "src/slack/poller.ts"
      provides: "Thread reply polling with exponential backoff and bot filtering"
      exports: ["pollForReply"]
      contains: "conversations.replies"
    - path: "src/tools/ask-human.ts"
      provides: "MCP tool handler with full question-poll-respond lifecycle"
      exports: ["registerAskHumanTool"]
      contains: "ask_human_via_slack"
    - path: "src/server.ts"
      provides: "MCP server entry point with stdio transport"
      contains: "StdioServerTransport"
  key_links:
    - from: "src/slack/poller.ts"
      to: "@slack/web-api"
      via: "conversations.replies API call"
      pattern: "conversations\\.replies"
    - from: "src/tools/ask-human.ts"
      to: "src/slack/messages.ts"
      via: "imports buildQuestionMessage for Slack posting"
      pattern: "import.*messages"
    - from: "src/tools/ask-human.ts"
      to: "src/slack/poller.ts"
      via: "imports pollForReply for thread watching"
      pattern: "import.*poller"
    - from: "src/server.ts"
      to: "src/tools/ask-human.ts"
      via: "registers tool on McpServer"
      pattern: "registerAskHumanTool"
    - from: "src/server.ts"
      to: "src/slack/client.ts"
      via: "creates SlackClient at startup"
      pattern: "createSlackClient"
---

<objective>
Build the poll manager and wire everything into a working MCP server. After this plan, `ask_human_via_slack` is a functional end-to-end tool: Claude calls it, a Slack message appears, the poll manager watches for a human reply, and the structured response flows back.

Purpose: This is the integration layer that makes the foundation modules (Plan 01) into a working product.
Output: Fully functional MCP server binary that can be added to Claude Code config.
</objective>

<execution_context>
@/Users/jdlnolen/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jdlnolen/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-slack-infrastructure-and-mcp-tool/01-CONTEXT.md
@.planning/phases/01-slack-infrastructure-and-mcp-tool/01-RESEARCH.md
@.planning/phases/01-slack-infrastructure-and-mcp-tool/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Thread reply poller with exponential backoff and bot filtering</name>
  <files>
    src/slack/poller.ts
  </files>
  <action>
Create `src/slack/poller.ts` implementing the poll manager per locked decisions:

1. Export `pollForReply(client, channelId, threadTs, botUserId, timeoutMs, opts?)` returning `Promise<PollResult>`:
   - Import `PollResult` from `../types.js`
   - Import `WebClient` from `@slack/web-api`

2. Polling loop:
   - Start with `delay = initialDelayMs` (default 3000 — 3 seconds per locked decision)
   - Cap at `maxDelayMs` (default 15000 — 15 seconds per locked decision)
   - Multiplier default: 1.5
   - Full jitter: actual delay = `Math.random() * baseDelay` where baseDelay grows exponentially. This prevents synchronized polling from multiple instances.
   - Loop while `Date.now() < deadline`

3. Each poll iteration:
   - Call `client.conversations.replies({ channel: channelId, ts: threadTs, oldest: threadTs, inclusive: false, limit: 10 })`
   - Belt-and-suspenders: also filter `msg.ts !== threadTs` in code (per research recommendation for Open Question #3)
   - Filter OUT messages where: `msg.bot_id` is truthy, OR `msg.subtype === "bot_message"`, OR `msg.user === botUserId`
   - For remaining human messages, apply substantive reply filter

4. Substantive reply filter (Claude's discretion — using character count approach per research recommendation):
   - Strip whitespace from reply text
   - Require at least 2 non-whitespace characters
   - Also reject pure emoji-only replies: if text after stripping whitespace matches only emoji codepoints (use a simple regex: `/^[\p{Emoji_Presentation}\p{Extended_Pictographic}\s]+$/u`), require at least 2 characters of non-emoji text
   - Allow common single-word acknowledgments via allowlist: ["yes", "no", "stop", "cancel", "approve", "approved", "reject", "rejected", "done", "skip", "continue", "proceed", "correct", "incorrect", "wrong", "right"]
   - This handles the pitfall of filtering "ok" while still accepting "yes" or "approve"

5. On match: return `PollResult` with `found: true`, text, user, ts, elapsedMs.
   On deadline reached: return `PollResult` with `found: false`, elapsedMs.

6. Export a `sleep(ms)` utility function (used by tool handler too).

CRITICAL: Never use `console.log()`. All debug logging via `console.error()`.
  </action>
  <verify>
Run `npx tsc --noEmit` — zero errors. Verify poller exports `pollForReply`. Grep for `console.log` — zero matches. Verify `conversations.replies` is called with `ts`, `oldest`, `inclusive: false`.
  </verify>
  <done>Poll manager calls conversations.replies with exponential backoff (3s start, 15s cap), filters bot messages by bot_id/subtype/user, filters short replies with character count + allowlist, and returns structured PollResult.</done>
</task>

<task type="auto">
  <name>Task 2: MCP server entry point and ask_human_via_slack tool handler</name>
  <files>
    src/tools/ask-human.ts
    src/server.ts
  </files>
  <action>
1. Create `src/tools/ask-human.ts`:
   - Import Zod for schema, McpServer type, SlackClient, message builders, pollForReply, Config, types
   - Define `AskHumanInputSchema` as a plain object of Zod fields (not z.object — MCP SDK's server.tool() takes the raw shape):
     - question: z.string().min(1).describe("The question to ask the human")
     - context: z.string().optional().describe("File path, error message, or code snippet for context")
     - options: z.array(z.string()).optional().describe("Numbered options for the human to choose from")
     - urgency: z.enum(["high", "normal", "low"]).optional().default("normal")
     - session_id: z.string().optional().describe("Session identifier for thread continuity")
   - Export `registerAskHumanTool(server: McpServer, slackClient: SlackClient, config: Config)`:
     - Call `server.tool("ask_human_via_slack", { title: "Ask Human via Slack", description: "Send a question to a human via Slack and wait for their reply. Use this whenever you need human input, approval, or a decision and the human may not be watching the terminal." }, AskHumanInputSchema, handler)`
     - Handler implementation:
       a. If `config.SEND_DELAY_MS > 0`, sleep for that duration first
       b. Build message via `buildQuestionMessage({ question, context, options, urgency, userId: config.SLACK_USER_ID ?? "" })`
       c. Post to Slack: `slackClient.web.chat.postMessage({ channel: slackClient.channelId, text: question, ...messagePayload })`
       d. If post fails or no `ts` returned, return `{ content: [{ type: "text", text: JSON.stringify({ error: "Failed to post question to Slack" }) }], isError: true }`
       e. First poll: `pollForReply(slackClient.web, slackClient.channelId, threadTs, slackClient.botUserId, config.POLL_TIMEOUT_MS)`
       f. If first poll times out (found === false):
          - Post "still waiting" bump via `buildStillWaitingMessage()` to thread
          - Second poll: same params, fresh timeout window
          - If second poll times out:
            - Post timeout notice via `buildTimeoutMessage()` to thread
            - Return `{ content: [{ type: "text", text: JSON.stringify({ error: "Timeout: No human response received", timeout_minutes: (config.POLL_TIMEOUT_MS * 2) / 60000 }) }], isError: true }`
       g. On successful reply:
          - Post response-received notice via `buildResponseReceivedMessage()` to thread
          - Parse numbered option selection if options were provided
          - Return structured response: `{ content: [{ type: "text", text: JSON.stringify({ reply, replied_by, response_time_ms, selected_option, selected_option_index }) }] }`
   - `formatReply` helper: if options provided and reply text is a number 1-N, set selected_option and selected_option_index

2. Create `src/server.ts`:
   - Import McpServer from `@modelcontextprotocol/sdk/server/mcp.js`
   - Import StdioServerTransport from `@modelcontextprotocol/sdk/server/stdio.js`
   - Import loadConfig, createSlackClient, registerAskHumanTool
   - Main async IIFE:
     a. `const config = loadConfig()` — fails fast if env vars invalid
     b. `const slackClient = await createSlackClient(config)` — validates token + gets bot user ID
     c. `const server = new McpServer({ name: "signal-flare", version: "0.1.0" }, { capabilities: {} })`
     d. `registerAskHumanTool(server, slackClient, config)`
     e. `const transport = new StdioServerTransport()`
     f. `await server.connect(transport)`
     g. `console.error("Signal Flare MCP server started")` — stderr only!
   - Wrap in try/catch: on error, `console.error("Fatal:", error)` and `process.exit(1)`

CRITICAL RULES:
- Zero `console.log()` calls — corrupts MCP stdio JSON-RPC stream
- Zero `as any` casts — strict TypeScript throughout
- All thread notices (timeout, still-waiting, response-received) are `chat.postMessage` with `thread_ts` as STRING (never number — per research pitfall #5)
  </action>
  <verify>
Run `npx tsc --noEmit` — zero errors. Run `npx tsup` — builds successfully to dist/server.js. Grep for `console.log` in src/ — zero matches. Grep for `as any` in src/ — zero matches. Verify dist/server.js starts with shebang line. Run `node dist/server.js 2>&1` without env vars — should exit with clear Zod validation error about missing SLACK_BOT_TOKEN (fail-fast behavior).
  </verify>
  <done>MCP server starts via stdio, validates config, connects to Slack, and registers ask_human_via_slack tool. Tool posts Block Kit questions, polls with auto-retry, handles timeouts with thread notices, and returns structured responses. Build produces dist/server.js ready for Claude Code MCP config. Missing env vars produce clear error messages.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `npx tsup` builds successfully to dist/server.js
3. `grep -r "console\.log" src/` returns zero matches
4. `grep -r "as any" src/` returns zero matches
5. `node dist/server.js` without env vars exits with Zod validation error mentioning SLACK_BOT_TOKEN
6. dist/server.js starts with `#!/usr/bin/env node` shebang
7. All thread messages use `thread_ts` parameter (string type)
8. Poll loop filters by bot_id, subtype, and user ID
9. Tool returns structured JSON with reply, replied_by, response_time_ms, selected_option fields
</verification>

<success_criteria>
- MCP server builds and starts successfully with valid env vars
- Without env vars, server exits immediately with helpful Zod error
- ask_human_via_slack tool is registered with correct Zod schema
- Poll manager uses exponential backoff (3s initial, 15s cap)
- Bot messages are never returned as human replies
- Auto-retry posts "still waiting" bump after first timeout window
- Final timeout posts "timed out" notice and returns error to Claude
- Successful reply posts "response received" notice and returns structured data
- dist/server.js is a valid Node.js executable with shebang
</success_criteria>

<output>
After completion, create `.planning/phases/01-slack-infrastructure-and-mcp-tool/01-02-SUMMARY.md`
</output>
